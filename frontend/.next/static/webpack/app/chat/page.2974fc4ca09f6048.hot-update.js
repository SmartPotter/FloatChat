"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/chat/page",{

/***/ "(app-pages-browser)/./src/lib/api-client.ts":
/*!*******************************!*\
  !*** ./src/lib/api-client.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: function() { return /* binding */ APIError; },\n/* harmony export */   apiClient: function() { return /* binding */ apiClient; },\n/* harmony export */   checkAPIHealth: function() { return /* binding */ checkAPIHealth; },\n/* harmony export */   handleAPIError: function() { return /* binding */ handleAPIError; }\n/* harmony export */ });\n/**\r\n * API client for FloatChat backend services.\r\n * \r\n * Provides typed interfaces for all backend API endpoints with proper\r\n * error handling and response transformation.\r\n */ const API_BASE_URL = \"http://localhost:8000\" || 0;\nclass APIError extends Error {\n    constructor(message, status, response){\n        super(message);\n        this.status = status;\n        this.response = response;\n        this.name = \"APIError\";\n    }\n}\nclass APIClient {\n    async request(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const url = \"\".concat(this.baseURL).concat(endpoint);\n        const defaultHeaders = {\n            \"Content-Type\": \"application/json\",\n            ...options.headers\n        };\n        try {\n            const response = await fetch(url, {\n                ...options,\n                headers: defaultHeaders\n            });\n            if (!response.ok) {\n                let errorMessage = \"HTTP \".concat(response.status, \": \").concat(response.statusText);\n                let errorData;\n                try {\n                    errorData = await response.json();\n                    if (errorData.detail) {\n                        errorMessage = errorData.detail;\n                    }\n                } catch (e) {\n                // Response is not JSON, use status text\n                }\n                throw new APIError(errorMessage, response.status, errorData);\n            }\n            // Handle empty responses (like 204 No Content)\n            if (response.status === 204 || response.headers.get(\"content-length\") === \"0\") {\n                return {};\n            }\n            const data = await response.json();\n            return data;\n        } catch (error) {\n            if (error instanceof APIError) {\n                throw error;\n            }\n            // Network or other errors\n            throw new APIError(error instanceof Error ? error.message : \"Network error\", 0);\n        }\n    }\n    // Health check\n    async healthCheck() {\n        return this.request(\"/api/health\");\n    }\n    // Data summary\n    async getDataSummary() {\n        return this.request(\"/api/data-summary\");\n    }\n    // Surface timeseries data\n    async getSurfaceTimeseries(params) {\n        const searchParams = new URLSearchParams({\n            lat: params.lat.toString(),\n            lon: params.lon.toString()\n        });\n        if (params.start) searchParams.append(\"start\", params.start);\n        if (params.end) searchParams.append(\"end\", params.end);\n        if (params.depth !== undefined) searchParams.append(\"depth\", params.depth.toString());\n        return this.request(\"/api/surface-timeseries?\".concat(searchParams));\n    }\n    // Vertical profile data\n    async getVerticalProfile(params) {\n        const searchParams = new URLSearchParams({\n            lat: params.lat.toString(),\n            lon: params.lon.toString(),\n            date: params.date\n        });\n        return this.request(\"/api/vertical-profile?\".concat(searchParams));\n    }\n    // Heat content data\n    async getHeatContent(params) {\n        const searchParams = new URLSearchParams({\n            lat: params.lat.toString(),\n            lon: params.lon.toString()\n        });\n        if (params.start) searchParams.append(\"start\", params.start);\n        if (params.end) searchParams.append(\"end\", params.end);\n        return this.request(\"/api/heat-content?\".concat(searchParams));\n    }\n    // Chat interface\n    async chatWithData(request) {\n        return this.request(\"/api/chat\", {\n            method: \"POST\",\n            body: JSON.stringify(request)\n        });\n    }\n    // NetCDF ingestion (stub)\n    async ingestNetCDF() {\n        return this.request(\"/api/ingest-netcdf\", {\n            method: \"POST\"\n        });\n    }\n    constructor(baseURL = API_BASE_URL){\n        this.baseURL = baseURL;\n    }\n}\n// Export singleton instance\nconst apiClient = new APIClient();\n// Export error class for error handling in components\n\n// Utility functions for error handling\nconst handleAPIError = (error)=>{\n    if (error instanceof APIError) {\n        return error.message;\n    }\n    if (error instanceof Error) {\n        return error.message;\n    }\n    return \"An unexpected error occurred\";\n};\n// Helper function to check API availability\nconst checkAPIHealth = async ()=>{\n    try {\n        await apiClient.healthCheck();\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpLWNsaWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FFRCxNQUFNQSxlQUFlQyx1QkFBK0IsSUFBSTtBQXFFeEQsTUFBTUcsaUJBQWlCQztJQUNyQkMsWUFDRUMsT0FBZSxFQUNmLE1BQXFCLEVBQ3JCLFFBQXFCLENBQ3JCO1FBQ0EsS0FBSyxDQUFDQTthQUhDQyxTQUFBQTthQUNBQyxXQUFBQTtRQUdQLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU1DO0lBT0osTUFBY0MsUUFDWkMsUUFBZ0IsRUFFSjtZQURaQyxVQUFBQSxpRUFBdUIsQ0FBQztRQUV4QixNQUFNQyxNQUFNLEdBQWtCRixPQUFmLElBQUksQ0FBQ0csT0FBTyxFQUFZLE9BQVRIO1FBRTlCLE1BQU1JLGlCQUFpQjtZQUNyQixnQkFBZ0I7WUFDaEIsR0FBR0gsUUFBUUksT0FBTztRQUNwQjtRQUVBLElBQUk7WUFDRixNQUFNVCxXQUFXLE1BQU1VLE1BQU1KLEtBQUs7Z0JBQ2hDLEdBQUdELE9BQU87Z0JBQ1ZJLFNBQVNEO1lBQ1g7WUFFQSxJQUFJLENBQUNSLFNBQVNXLEVBQUUsRUFBRTtnQkFDaEIsSUFBSUMsZUFBZSxRQUE0QlosT0FBcEJBLFNBQVNELE1BQU0sRUFBQyxNQUF3QixPQUFwQkMsU0FBU2EsVUFBVTtnQkFDbEUsSUFBSUM7Z0JBRUosSUFBSTtvQkFDRkEsWUFBWSxNQUFNZCxTQUFTZSxJQUFJO29CQUMvQixJQUFJRCxVQUFVRSxNQUFNLEVBQUU7d0JBQ3BCSixlQUFlRSxVQUFVRSxNQUFNO29CQUNqQztnQkFDRixFQUFFLFVBQU07Z0JBQ04sd0NBQXdDO2dCQUMxQztnQkFFQSxNQUFNLElBQUlyQixTQUFTaUIsY0FBY1osU0FBU0QsTUFBTSxFQUFFZTtZQUNwRDtZQUVBLCtDQUErQztZQUMvQyxJQUFJZCxTQUFTRCxNQUFNLEtBQUssT0FBT0MsU0FBU1MsT0FBTyxDQUFD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QUFJcUIsaUJBQWlCdkIsT0FBTztRQUMxQixPQUFPdUIsTUFBTXJCLE9BQU87SUFDdEI7SUFDQSxPQUFPO0FBQ1QsRUFBQztBQUVELDRDQUE0QztBQUNyQyxNQUFNK0MsaUJBQWlCO0lBQzVCLElBQUk7UUFDRixNQUFNRixVQUFVdkIsV0FBVztRQUMzQixPQUFPO0lBQ1QsRUFBRSxVQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0YsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2FwaS1jbGllbnQudHM/YWMxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQVBJIGNsaWVudCBmb3IgRmxvYXRDaGF0IGJhY2tlbmQgc2VydmljZXMuXHJcbiAqIFxyXG4gKiBQcm92aWRlcyB0eXBlZCBpbnRlcmZhY2VzIGZvciBhbGwgYmFja2VuZCBBUEkgZW5kcG9pbnRzIHdpdGggcHJvcGVyXHJcbiAqIGVycm9yIGhhbmRsaW5nIGFuZCByZXNwb25zZSB0cmFuc2Zvcm1hdGlvbi5cclxuICovXHJcblxyXG5jb25zdCBBUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAnXHJcblxyXG4vLyBUeXBlIGRlZmluaXRpb25zIGZvciBBUEkgcmVzcG9uc2VzXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVN1bW1hcnkge1xyXG4gIHRvdGFsX3JlY29yZHM6IG51bWJlclxyXG4gIGRhdGVfcmFuZ2U6IHsgc3RhcnQ6IHN0cmluZzsgZW5kOiBzdHJpbmcgfVxyXG4gIHNwYXRpYWxfY292ZXJhZ2U6IHtcclxuICAgIGxhdGl0dWRlOiB7IG1pbjogbnVtYmVyOyBtYXg6IG51bWJlciB9XHJcbiAgICBsb25naXR1ZGU6IHsgbWluOiBudW1iZXI7IG1heDogbnVtYmVyIH1cclxuICB9XHJcbiAgZGF0YV90eXBlczogc3RyaW5nW11cclxuICBtZWFzdXJlbWVudF9jb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUaW1lU2VyaWVzUG9pbnQge1xyXG4gIHRpbWU6IHN0cmluZ1xyXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyXHJcbiAgc2FsaW5pdHk/OiBudW1iZXJcclxuICBkZXB0aD86IG51bWJlclxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFZlcnRpY2FsUHJvZmlsZVBvaW50IHtcclxuICBkZXB0aDogbnVtYmVyXHJcbiAgdGVtcGVyYXR1cmU/OiBudW1iZXJcclxuICBzYWxpbml0eT86IG51bWJlclxyXG4gIGRhdGU6IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEhlYXRDb250ZW50UG9pbnQge1xyXG4gIHRpbWU6IHN0cmluZ1xyXG4gIGxhdDogbnVtYmVyXHJcbiAgbG9uOiBudW1iZXJcclxuICBoZWF0X2NvbnRlbnQ6IG51bWJlclxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENoYXRSZXF1ZXN0IHtcclxuICBtZXNzYWdlOiBzdHJpbmdcclxuICBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55PlxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENoYXRSZXNwb25zZSB7XHJcbiAgcmVzcG9uc2U6IHN0cmluZ1xyXG4gIHRpbWVzdGFtcDogc3RyaW5nXHJcbiAgc291cmNlcz86IHN0cmluZ1tdXHJcbiAgY29uZmlkZW5jZT86IG51bWJlclxyXG59XHJcblxyXG4vLyBBUEkgcXVlcnkgcGFyYW1ldGVyc1xyXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVTZXJpZXNQYXJhbXMge1xyXG4gIGxhdDogbnVtYmVyXHJcbiAgbG9uOiBudW1iZXJcclxuICBzdGFydD86IHN0cmluZ1xyXG4gIGVuZD86IHN0cmluZ1xyXG4gIGRlcHRoPzogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVmVydGljYWxQcm9maWxlUGFyYW1zIHtcclxuICBsYXQ6IG51bWJlclxyXG4gIGxvbjogbnVtYmVyXHJcbiAgZGF0ZTogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSGVhdENvbnRlbnRQYXJhbXMge1xyXG4gIGxhdDogbnVtYmVyXHJcbiAgbG9uOiBudW1iZXJcclxuICBzdGFydD86IHN0cmluZ1xyXG4gIGVuZD86IHN0cmluZ1xyXG59XHJcblxyXG5jbGFzcyBBUElFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIG1lc3NhZ2U6IHN0cmluZyxcclxuICAgIHB1YmxpYyBzdGF0dXM6IG51bWJlcixcclxuICAgIHB1YmxpYyByZXNwb25zZT86IGFueVxyXG4gICkge1xyXG4gICAgc3VwZXIobWVzc2FnZSlcclxuICAgIHRoaXMubmFtZSA9ICdBUElFcnJvcidcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEFQSUNsaWVudCB7XHJcbiAgcHJpdmF0ZSBiYXNlVVJMOiBzdHJpbmdcclxuXHJcbiAgY29uc3RydWN0b3IoYmFzZVVSTDogc3RyaW5nID0gQVBJX0JBU0VfVVJMKSB7XHJcbiAgICB0aGlzLmJhc2VVUkwgPSBiYXNlVVJMXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHJlcXVlc3Q8VD4oXHJcbiAgICBlbmRwb2ludDogc3RyaW5nLFxyXG4gICAgb3B0aW9uczogUmVxdWVzdEluaXQgPSB7fVxyXG4gICk6IFByb21pc2U8VD4ge1xyXG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVVJMfSR7ZW5kcG9pbnR9YFxyXG4gICAgXHJcbiAgICBjb25zdCBkZWZhdWx0SGVhZGVycyA9IHtcclxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XHJcbiAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICBoZWFkZXJzOiBkZWZhdWx0SGVhZGVycyxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxyXG4gICAgICAgIGxldCBlcnJvckRhdGFcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICAgICAgaWYgKGVycm9yRGF0YS5kZXRhaWwpIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JEYXRhLmRldGFpbFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgLy8gUmVzcG9uc2UgaXMgbm90IEpTT04sIHVzZSBzdGF0dXMgdGV4dFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKGVycm9yTWVzc2FnZSwgcmVzcG9uc2Uuc3RhdHVzLCBlcnJvckRhdGEpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEhhbmRsZSBlbXB0eSByZXNwb25zZXMgKGxpa2UgMjA0IE5vIENvbnRlbnQpXHJcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNCB8fCByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKSA9PT0gJzAnKSB7XHJcbiAgICAgICAgcmV0dXJuIHt9IGFzIFRcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICByZXR1cm4gZGF0YSBhcyBUXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBUElFcnJvcikge1xyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5ldHdvcmsgb3Igb3RoZXIgZXJyb3JzXHJcbiAgICAgIHRocm93IG5ldyBBUElFcnJvcihcclxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdOZXR3b3JrIGVycm9yJyxcclxuICAgICAgICAwXHJcbiAgICAgIClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEhlYWx0aCBjaGVja1xyXG4gIGFzeW5jIGhlYWx0aENoZWNrKCk6IFByb21pc2U8eyBzdGF0dXM6IHN0cmluZzsgdGltZXN0YW1wOiBzdHJpbmc7IHZlcnNpb246IHN0cmluZyB9PiB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCcvYXBpL2hlYWx0aCcpXHJcbiAgfVxyXG5cclxuICAvLyBEYXRhIHN1bW1hcnlcclxuICBhc3luYyBnZXREYXRhU3VtbWFyeSgpOiBQcm9taXNlPERhdGFTdW1tYXJ5PiB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCcvYXBpL2RhdGEtc3VtbWFyeScpXHJcbiAgfVxyXG5cclxuICAvLyBTdXJmYWNlIHRpbWVzZXJpZXMgZGF0YVxyXG4gIGFzeW5jIGdldFN1cmZhY2VUaW1lc2VyaWVzKHBhcmFtczogVGltZVNlcmllc1BhcmFtcyk6IFByb21pc2U8VGltZVNlcmllc1BvaW50W10+IHtcclxuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xyXG4gICAgICBsYXQ6IHBhcmFtcy5sYXQudG9TdHJpbmcoKSxcclxuICAgICAgbG9uOiBwYXJhbXMubG9uLnRvU3RyaW5nKCksXHJcbiAgICB9KVxyXG5cclxuICAgIGlmIChwYXJhbXMuc3RhcnQpIHNlYXJjaFBhcmFtcy5hcHBlbmQoJ3N0YXJ0JywgcGFyYW1zLnN0YXJ0KVxyXG4gICAgaWYgKHBhcmFtcy5lbmQpIHNlYXJjaFBhcmFtcy5hcHBlbmQoJ2VuZCcsIHBhcmFtcy5lbmQpXHJcbiAgICBpZiAocGFyYW1zLmRlcHRoICE9PSB1bmRlZmluZWQpIHNlYXJjaFBhcmFtcy5hcHBlbmQoJ2RlcHRoJywgcGFyYW1zLmRlcHRoLnRvU3RyaW5nKCkpXHJcblxyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9zdXJmYWNlLXRpbWVzZXJpZXM/JHtzZWFyY2hQYXJhbXN9YClcclxuICB9XHJcblxyXG4gIC8vIFZlcnRpY2FsIHByb2ZpbGUgZGF0YVxyXG4gIGFzeW5jIGdldFZlcnRpY2FsUHJvZmlsZShwYXJhbXM6IFZlcnRpY2FsUHJvZmlsZVBhcmFtcyk6IFByb21pc2U8VmVydGljYWxQcm9maWxlUG9pbnRbXT4ge1xyXG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XHJcbiAgICAgIGxhdDogcGFyYW1zLmxhdC50b1N0cmluZygpLFxyXG4gICAgICBsb246IHBhcmFtcy5sb24udG9TdHJpbmcoKSxcclxuICAgICAgZGF0ZTogcGFyYW1zLmRhdGUsXHJcbiAgICB9KVxyXG5cclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvdmVydGljYWwtcHJvZmlsZT8ke3NlYXJjaFBhcmFtc31gKVxyXG4gIH1cclxuXHJcbiAgLy8gSGVhdCBjb250ZW50IGRhdGFcclxuICBhc3luYyBnZXRIZWF0Q29udGVudChwYXJhbXM6IEhlYXRDb250ZW50UGFyYW1zKTogUHJvbWlzZTxIZWF0Q29udGVudFBvaW50W10+IHtcclxuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xyXG4gICAgICBsYXQ6IHBhcmFtcy5sYXQudG9TdHJpbmcoKSxcclxuICAgICAgbG9uOiBwYXJhbXMubG9uLnRvU3RyaW5nKCksXHJcbiAgICB9KVxyXG5cclxuICAgIGlmIChwYXJhbXMuc3RhcnQpIHNlYXJjaFBhcmFtcy5hcHBlbmQoJ3N0YXJ0JywgcGFyYW1zLnN0YXJ0KVxyXG4gICAgaWYgKHBhcmFtcy5lbmQpIHNlYXJjaFBhcmFtcy5hcHBlbmQoJ2VuZCcsIHBhcmFtcy5lbmQpXHJcblxyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9oZWF0LWNvbnRlbnQ/JHtzZWFyY2hQYXJhbXN9YClcclxuICB9XHJcblxyXG4gIC8vIENoYXQgaW50ZXJmYWNlXHJcbiAgYXN5bmMgY2hhdFdpdGhEYXRhKHJlcXVlc3Q6IENoYXRSZXF1ZXN0KTogUHJvbWlzZTxDaGF0UmVzcG9uc2U+IHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJy9hcGkvY2hhdCcsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLFxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIC8vIE5ldENERiBpbmdlc3Rpb24gKHN0dWIpXHJcbiAgYXN5bmMgaW5nZXN0TmV0Q0RGKCk6IFByb21pc2U8eyBzdGF0dXM6IHN0cmluZzsgbWVzc2FnZTogc3RyaW5nIH0+IHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJy9hcGkvaW5nZXN0LW5ldGNkZicsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICB9KVxyXG4gIH1cclxufVxyXG5cclxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxyXG5leHBvcnQgY29uc3QgYXBpQ2xpZW50ID0gbmV3IEFQSUNsaWVudCgpXHJcblxyXG4vLyBFeHBvcnQgZXJyb3IgY2xhc3MgZm9yIGVycm9yIGhhbmRsaW5nIGluIGNvbXBvbmVudHNcclxuZXhwb3J0IHsgQVBJRXJyb3IgfVxyXG5cclxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGVycm9yIGhhbmRsaW5nXHJcbmV4cG9ydCBjb25zdCBoYW5kbGVBUElFcnJvciA9IChlcnJvcjogdW5rbm93bik6IHN0cmluZyA9PiB7XHJcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgQVBJRXJyb3IpIHtcclxuICAgIHJldHVybiBlcnJvci5tZXNzYWdlXHJcbiAgfVxyXG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZVxyXG4gIH1cclxuICByZXR1cm4gJ0FuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQnXHJcbn1cclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBBUEkgYXZhaWxhYmlsaXR5XHJcbmV4cG9ydCBjb25zdCBjaGVja0FQSUhlYWx0aCA9IGFzeW5jICgpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgYXBpQ2xpZW50LmhlYWx0aENoZWNrKClcclxuICAgIHJldHVybiB0cnVlXHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbn0iXSwibmFtZXMiOlsiQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJBUElFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwic3RhdHVzIiwicmVzcG9uc2UiLCJuYW1lIiwiQVBJQ2xpZW50IiwicmVxdWVzdCIsImVuZHBvaW50Iiwib3B0aW9ucyIsInVybCIsImJhc2VVUkwiLCJkZWZhdWx0SGVhZGVycyIsImhlYWRlcnMiLCJmZXRjaCIsIm9rIiwiZXJyb3JNZXNzYWdlIiwic3RhdHVzVGV4dCIsImVycm9yRGF0YSIsImpzb24iLCJkZXRhaWwiLCJnZXQiLCJkYXRhIiwiZXJyb3IiLCJoZWFsdGhDaGVjayIsImdldERhdGFTdW1tYXJ5IiwiZ2V0U3VyZmFjZVRpbWVzZXJpZXMiLCJwYXJhbXMiLCJzZWFyY2hQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJsYXQiLCJ0b1N0cmluZyIsImxvbiIsInN0YXJ0IiwiYXBwZW5kIiwiZW5kIiwiZGVwdGgiLCJ1bmRlZmluZWQiLCJnZXRWZXJ0aWNhbFByb2ZpbGUiLCJkYXRlIiwiZ2V0SGVhdENvbnRlbnQiLCJjaGF0V2l0aERhdGEiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImluZ2VzdE5ldENERiIsImFwaUNsaWVudCIsImhhbmRsZUFQSUVycm9yIiwiY2hlY2tBUElIZWFsdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api-client.ts\n"));

/***/ })

});