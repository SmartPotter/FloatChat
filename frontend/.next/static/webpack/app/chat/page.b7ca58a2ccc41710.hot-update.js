"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/chat/page",{

/***/ "(app-pages-browser)/./src/lib/api-client.ts":
/*!*******************************!*\
  !*** ./src/lib/api-client.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: function() { return /* binding */ APIError; },\n/* harmony export */   apiClient: function() { return /* binding */ apiClient; },\n/* harmony export */   checkAPIHealth: function() { return /* binding */ checkAPIHealth; },\n/* harmony export */   handleAPIError: function() { return /* binding */ handleAPIError; }\n/* harmony export */ });\n/**\r\n * API client for FloatChat backend services.\r\n * \r\n * Provides typed interfaces for all backend API endpoints with proper\r\n * error handling and response transformation.\r\n */ const API_BASE_URL = \"http://localhost:8000\" || 0;\nclass APIError extends Error {\n    constructor(message, status, response){\n        super(message);\n        this.status = status;\n        this.response = response;\n        this.name = \"APIError\";\n    }\n}\nclass APIClient {\n    async request(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const url = \"\".concat(this.baseURL).concat(endpoint);\n        const defaultHeaders = {\n            \"Content-Type\": \"application/json\",\n            ...options.headers\n        };\n        try {\n            const response = await fetch(url, {\n                ...options,\n                headers: defaultHeaders\n            });\n            if (!response.ok) {\n                let errorMessage = \"HTTP \".concat(response.status, \": \").concat(response.statusText);\n                let errorData;\n                try {\n                    errorData = await response.json();\n                    if (errorData.detail) {\n                        errorMessage = errorData.detail;\n                    }\n                } catch (e) {\n                // Response is not JSON, use status text\n                }\n                throw new APIError(errorMessage, response.status, errorData);\n            }\n            // Handle empty responses (like 204 No Content)\n            if (response.status === 204 || response.headers.get(\"content-length\") === \"0\") {\n                return {};\n            }\n            const data = await response.json();\n            return data;\n        } catch (error) {\n            if (error instanceof APIError) {\n                throw error;\n            }\n            // Network or other errors\n            throw new APIError(error instanceof Error ? error.message : \"Network error\", 0);\n        }\n    }\n    // Health check\n    async healthCheck() {\n        return this.request(\"/api/health\");\n    }\n    // Data summary\n    async getDataSummary() {\n        return this.request(\"/api/data-summary\");\n    }\n    // Surface timeseries data\n    async getSurfaceTimeseries(params) {\n        const searchParams = new URLSearchParams({\n            lat: params.lat.toString(),\n            lon: params.lon.toString()\n        });\n        if (params.start) searchParams.append(\"start\", params.start);\n        if (params.end) searchParams.append(\"end\", params.end);\n        if (params.depth !== undefined) searchParams.append(\"depth\", params.depth.toString());\n        return this.request(\"/api/surface-timeseries?\".concat(searchParams));\n    }\n    // Vertical profile data\n    async getVerticalProfile(params) {\n        const searchParams = new URLSearchParams({\n            lat: params.lat.toString(),\n            lon: params.lon.toString(),\n            date: params.date\n        });\n        return this.request(\"/api/vertical-profile?\".concat(searchParams));\n    }\n    // Heat content data\n    async getHeatContent(params) {\n        const searchParams = new URLSearchParams({\n            lat: params.lat.toString(),\n            lon: params.lon.toString()\n        });\n        if (params.start) searchParams.append(\"start\", params.start);\n        if (params.end) searchParams.append(\"end\", params.end);\n        return this.request(\"/api/heat-content?\".concat(searchParams));\n    }\n    // Chat interface\n    async chatWithData(request) {\n        return this.request(\"/api/chat\", {\n            method: \"POST\",\n            body: JSON.stringify(request)\n        });\n    }\n    // NetCDF ingestion (stub)\n    async ingestNetCDF() {\n        return this.request(\"/api/ingest-netcdf\", {\n            method: \"POST\"\n        });\n    }\n    constructor(baseURL = API_BASE_URL){\n        this.baseURL = baseURL;\n    }\n}\n// Export singleton instance\nconst apiClient = new APIClient();\n// Export error class for error handling in components\n\n// Utility functions for error handling\nconst handleAPIError = (error)=>{\n    if (error instanceof APIError) {\n        return error.message;\n    }\n    if (error instanceof Error) {\n        return error.message;\n    }\n    return \"An unexpected error occurred\";\n};\n// Helper function to check API availability\nconst checkAPIHealth = async ()=>{\n    try {\n        await apiClient.healthCheck();\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpLWNsaWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FFRCxNQUFNQSxlQUFlQyx1QkFBK0IsSUFBSTtBQXVFeEQsTUFBTUcsaUJBQWlCQztJQUNyQkMsWUFDRUMsT0FBZSxFQUNmLE1BQXFCLEVBQ3JCLFFBQXFCLENBQ3JCO1FBQ0EsS0FBSyxDQUFDQTthQUhDQyxTQUFBQTthQUNBQyxXQUFBQTtRQUdQLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU1DO0lBT0osTUFBY0MsUUFDWkMsUUFBZ0IsRUFFSjtZQURaQyxVQUFBQSxpRUFBdUIsQ0FBQztRQUV4QixNQUFNQyxNQUFNLEdBQWtCRixPQUFmLElBQUksQ0FBQ0csT0FBTyxFQUFZLE9BQVRIO1FBRTlCLE1BQU1JLGlCQUFpQjtZQUNyQixnQkFBZ0I7WUFDaEIsR0FBR0gsUUFBUUksT0FBTztRQUNwQjtRQUVBLElBQUk7WUFDRixNQUFNVCxXQUFXLE1BQU1VLE1BQU1KLEtBQUs7Z0JBQ2hDLEdBQUdELE9BQU87Z0JBQ1ZJLFNBQVNEO1lBQ1g7WUFFQSxJQUFJLENBQUNSLFNBQVNXLEVBQUUsRUFBRTtnQkFDaEIsSUFBSUMsZUFBZSxRQUE0QlosT0FBcEJBLFNBQVNELE1BQU0sRUFBQyxNQUF3QixPQUFwQkMsU0FBU2EsVUFBVTtnQkFDbEUsSUFBSUM7Z0JBRUosSUFBSTtvQkFDRkEsWUFBWSxNQUFNZCxTQUFTZSxJQUFJO29CQUMvQixJQUFJRCxVQUFVRSxNQUFNLEVBQUU7d0JBQ3BCSixlQUFlRSxVQUFVRSxNQUFNO29CQUNqQztnQkFDRixFQUFFLFVBQU07Z0JBQ04sd0NBQXdDO2dCQUMxQztnQkFFQSxNQUFNLElBQUlyQixTQUFTaUIsY0FBY1osU0FBU0QsTUFBTSxFQUFFZTtZQUNwRDtZQUVBLCtDQUErQztZQUMvQyxJQUFJZCxTQUFTRCxNQUFNLEtBQUssT0FBT0MsU0FBU1MsT0FBTyxDQUFD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QUFJcUIsaUJBQWlCdkIsT0FBTztRQUMxQixPQUFPdUIsTUFBTXJCLE9BQU87SUFDdEI7SUFDQSxPQUFPO0FBQ1QsRUFBQztBQUVELDRDQUE0QztBQUNyQyxNQUFNK0MsaUJBQWlCO0lBQzVCLElBQUk7UUFDRixNQUFNRixVQUFVdkIsV0FBVztRQUMzQixPQUFPO0lBQ1QsRUFBRSxVQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0YsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2FwaS1jbGllbnQudHM/YWMxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQVBJIGNsaWVudCBmb3IgRmxvYXRDaGF0IGJhY2tlbmQgc2VydmljZXMuXHJcbiAqIFxyXG4gKiBQcm92aWRlcyB0eXBlZCBpbnRlcmZhY2VzIGZvciBhbGwgYmFja2VuZCBBUEkgZW5kcG9pbnRzIHdpdGggcHJvcGVyXHJcbiAqIGVycm9yIGhhbmRsaW5nIGFuZCByZXNwb25zZSB0cmFuc2Zvcm1hdGlvbi5cclxuICovXHJcblxyXG5jb25zdCBBUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAnXHJcblxyXG4vLyBUeXBlIGRlZmluaXRpb25zIGZvciBBUEkgcmVzcG9uc2VzXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVN1bW1hcnkge1xyXG4gIHRvdGFsX3JlY29yZHM6IG51bWJlclxyXG4gIGRhdGVfcmFuZ2U6IHsgc3RhcnQ6IHN0cmluZzsgZW5kOiBzdHJpbmcgfVxyXG4gIHNwYXRpYWxfY292ZXJhZ2U6IHtcclxuICAgIGxhdGl0dWRlOiB7IG1pbjogbnVtYmVyOyBtYXg6IG51bWJlciB9XHJcbiAgICBsb25naXR1ZGU6IHsgbWluOiBudW1iZXI7IG1heDogbnVtYmVyIH1cclxuICB9XHJcbiAgZGF0YV90eXBlczogc3RyaW5nW11cclxuICBtZWFzdXJlbWVudF9jb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUaW1lU2VyaWVzUG9pbnQge1xyXG4gIHRpbWU6IHN0cmluZ1xyXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyXHJcbiAgc2FsaW5pdHk/OiBudW1iZXJcclxuICBkZXB0aD86IG51bWJlclxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFZlcnRpY2FsUHJvZmlsZVBvaW50IHtcclxuICBkZXB0aDogbnVtYmVyXHJcbiAgdGVtcGVyYXR1cmU/OiBudW1iZXJcclxuICBzYWxpbml0eT86IG51bWJlclxyXG4gIGRhdGU6IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEhlYXRDb250ZW50UG9pbnQge1xyXG4gIHRpbWU6IHN0cmluZ1xyXG4gIGxhdDogbnVtYmVyXHJcbiAgbG9uOiBudW1iZXJcclxuICBoZWF0X2NvbnRlbnQ6IG51bWJlclxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENoYXRSZXF1ZXN0IHtcclxuICBtZXNzYWdlOiBzdHJpbmdcclxuICBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55PlxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENoYXRSZXNwb25zZSB7XHJcbiAgcmVzcG9uc2U6IHN0cmluZ1xyXG4gIHRpbWVzdGFtcDogc3RyaW5nXHJcbiAgc291cmNlcz86IHN0cmluZ1tdXHJcbiAgY29uZmlkZW5jZT86IG51bWJlclxyXG59XHJcblxyXG4vLyBBUEkgcXVlcnkgcGFyYW1ldGVyc1xyXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVTZXJpZXNQYXJhbXMge1xyXG4gIGxhdDogbnVtYmVyXHJcbiAgbG9uOiBudW1iZXJcclxuICBzdGFydD86IHN0cmluZ1xyXG4gIGVuZD86IHN0cmluZ1xyXG4gIGRlcHRoPzogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVmVydGljYWxQcm9maWxlUGFyYW1zIHtcclxuICBsYXQ6IG51bWJlclxyXG4gIGxvbjogbnVtYmVyXHJcbiAgZGF0ZTogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSGVhdENvbnRlbnRQYXJhbXMge1xyXG4gIGxhdDogbnVtYmVyXHJcbiAgbG9uOiBudW1iZXJcclxuICBzdGFydD86IHN0cmluZ1xyXG4gIGVuZD86IHN0cmluZ1xyXG59XHJcblxyXG5cclxuXHJcbmNsYXNzIEFQSUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgbWVzc2FnZTogc3RyaW5nLFxyXG4gICAgcHVibGljIHN0YXR1czogbnVtYmVyLFxyXG4gICAgcHVibGljIHJlc3BvbnNlPzogYW55XHJcbiAgKSB7XHJcbiAgICBzdXBlcihtZXNzYWdlKVxyXG4gICAgdGhpcy5uYW1lID0gJ0FQSUVycm9yJ1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgQVBJQ2xpZW50IHtcclxuICBwcml2YXRlIGJhc2VVUkw6IHN0cmluZ1xyXG5cclxuICBjb25zdHJ1Y3RvcihiYXNlVVJMOiBzdHJpbmcgPSBBUElfQkFTRV9VUkwpIHtcclxuICAgIHRoaXMuYmFzZVVSTCA9IGJhc2VVUkxcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcmVxdWVzdDxUPihcclxuICAgIGVuZHBvaW50OiBzdHJpbmcsXHJcbiAgICBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHt9XHJcbiAgKTogUHJvbWlzZTxUPiB7XHJcbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVUkx9JHtlbmRwb2ludH1gXHJcbiAgICBcclxuICAgIGNvbnN0IGRlZmF1bHRIZWFkZXJzID0ge1xyXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcclxuICAgICAgICAuLi5vcHRpb25zLFxyXG4gICAgICAgIGhlYWRlcnM6IGRlZmF1bHRIZWFkZXJzLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gXHJcbiAgICAgICAgbGV0IGVycm9yRGF0YVxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbiAgICAgICAgICBpZiAoZXJyb3JEYXRhLmRldGFpbCkge1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvckRhdGEuZGV0YWlsXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICAvLyBSZXNwb25zZSBpcyBub3QgSlNPTiwgdXNlIHN0YXR1cyB0ZXh0XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aHJvdyBuZXcgQVBJRXJyb3IoZXJyb3JNZXNzYWdlLCByZXNwb25zZS5zdGF0dXMsIGVycm9yRGF0YSlcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSGFuZGxlIGVtcHR5IHJlc3BvbnNlcyAobGlrZSAyMDQgTm8gQ29udGVudClcclxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0IHx8IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LWxlbmd0aCcpID09PSAnMCcpIHtcclxuICAgICAgICByZXR1cm4ge30gYXMgVFxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbiAgICAgIHJldHVybiBkYXRhIGFzIFRcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFQSUVycm9yKSB7XHJcbiAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTmV0d29yayBvciBvdGhlciBlcnJvcnNcclxuICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKFxyXG4gICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ05ldHdvcmsgZXJyb3InLFxyXG4gICAgICAgIDBcclxuICAgICAgKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSGVhbHRoIGNoZWNrXHJcbiAgYXN5bmMgaGVhbHRoQ2hlY2soKTogUHJvbWlzZTx7IHN0YXR1czogc3RyaW5nOyB0aW1lc3RhbXA6IHN0cmluZzsgdmVyc2lvbjogc3RyaW5nIH0+IHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJy9hcGkvaGVhbHRoJylcclxuICB9XHJcblxyXG4gIC8vIERhdGEgc3VtbWFyeVxyXG4gIGFzeW5jIGdldERhdGFTdW1tYXJ5KCk6IFByb21pc2U8RGF0YVN1bW1hcnk+IHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJy9hcGkvZGF0YS1zdW1tYXJ5JylcclxuICB9XHJcblxyXG4gIC8vIFN1cmZhY2UgdGltZXNlcmllcyBkYXRhXHJcbiAgYXN5bmMgZ2V0U3VyZmFjZVRpbWVzZXJpZXMocGFyYW1zOiBUaW1lU2VyaWVzUGFyYW1zKTogUHJvbWlzZTxUaW1lU2VyaWVzUG9pbnRbXT4ge1xyXG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XHJcbiAgICAgIGxhdDogcGFyYW1zLmxhdC50b1N0cmluZygpLFxyXG4gICAgICBsb246IHBhcmFtcy5sb24udG9TdHJpbmcoKSxcclxuICAgIH0pXHJcblxyXG4gICAgaWYgKHBhcmFtcy5zdGFydCkgc2VhcmNoUGFyYW1zLmFwcGVuZCgnc3RhcnQnLCBwYXJhbXMuc3RhcnQpXHJcbiAgICBpZiAocGFyYW1zLmVuZCkgc2VhcmNoUGFyYW1zLmFwcGVuZCgnZW5kJywgcGFyYW1zLmVuZClcclxuICAgIGlmIChwYXJhbXMuZGVwdGggIT09IHVuZGVmaW5lZCkgc2VhcmNoUGFyYW1zLmFwcGVuZCgnZGVwdGgnLCBwYXJhbXMuZGVwdGgudG9TdHJpbmcoKSlcclxuXHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL3N1cmZhY2UtdGltZXNlcmllcz8ke3NlYXJjaFBhcmFtc31gKVxyXG4gIH1cclxuXHJcbiAgLy8gVmVydGljYWwgcHJvZmlsZSBkYXRhXHJcbiAgYXN5bmMgZ2V0VmVydGljYWxQcm9maWxlKHBhcmFtczogVmVydGljYWxQcm9maWxlUGFyYW1zKTogUHJvbWlzZTxWZXJ0aWNhbFByb2ZpbGVQb2ludFtdPiB7XHJcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcclxuICAgICAgbGF0OiBwYXJhbXMubGF0LnRvU3RyaW5nKCksXHJcbiAgICAgIGxvbjogcGFyYW1zLmxvbi50b1N0cmluZygpLFxyXG4gICAgICBkYXRlOiBwYXJhbXMuZGF0ZSxcclxuICAgIH0pXHJcblxyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS92ZXJ0aWNhbC1wcm9maWxlPyR7c2VhcmNoUGFyYW1zfWApXHJcbiAgfVxyXG5cclxuICAvLyBIZWF0IGNvbnRlbnQgZGF0YVxyXG4gIGFzeW5jIGdldEhlYXRDb250ZW50KHBhcmFtczogSGVhdENvbnRlbnRQYXJhbXMpOiBQcm9taXNlPEhlYXRDb250ZW50UG9pbnRbXT4ge1xyXG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XHJcbiAgICAgIGxhdDogcGFyYW1zLmxhdC50b1N0cmluZygpLFxyXG4gICAgICBsb246IHBhcmFtcy5sb24udG9TdHJpbmcoKSxcclxuICAgIH0pXHJcblxyXG4gICAgaWYgKHBhcmFtcy5zdGFydCkgc2VhcmNoUGFyYW1zLmFwcGVuZCgnc3RhcnQnLCBwYXJhbXMuc3RhcnQpXHJcbiAgICBpZiAocGFyYW1zLmVuZCkgc2VhcmNoUGFyYW1zLmFwcGVuZCgnZW5kJywgcGFyYW1zLmVuZClcclxuXHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL2hlYXQtY29udGVudD8ke3NlYXJjaFBhcmFtc31gKVxyXG4gIH1cclxuXHJcbiAgLy8gQ2hhdCBpbnRlcmZhY2VcclxuICBhc3luYyBjaGF0V2l0aERhdGEocmVxdWVzdDogQ2hhdFJlcXVlc3QpOiBQcm9taXNlPENoYXRSZXNwb25zZT4ge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnL2FwaS9jaGF0Jywge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLy8gTmV0Q0RGIGluZ2VzdGlvbiAoc3R1YilcclxuICBhc3luYyBpbmdlc3ROZXRDREYoKTogUHJvbWlzZTx7IHN0YXR1czogc3RyaW5nOyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnL2FwaS9pbmdlc3QtbmV0Y2RmJywge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgIH0pXHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBhcGlDbGllbnQgPSBuZXcgQVBJQ2xpZW50KClcclxuXHJcbi8vIEV4cG9ydCBlcnJvciBjbGFzcyBmb3IgZXJyb3IgaGFuZGxpbmcgaW4gY29tcG9uZW50c1xyXG5leHBvcnQgeyBBUElFcnJvciB9XHJcblxyXG4vLyBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZXJyb3IgaGFuZGxpbmdcclxuZXhwb3J0IGNvbnN0IGhhbmRsZUFQSUVycm9yID0gKGVycm9yOiB1bmtub3duKTogc3RyaW5nID0+IHtcclxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBUElFcnJvcikge1xyXG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2VcclxuICB9XHJcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgIHJldHVybiBlcnJvci5tZXNzYWdlXHJcbiAgfVxyXG4gIHJldHVybiAnQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZCdcclxufVxyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIEFQSSBhdmFpbGFiaWxpdHlcclxuZXhwb3J0IGNvbnN0IGNoZWNrQVBJSGVhbHRoID0gYXN5bmMgKCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBhcGlDbGllbnQuaGVhbHRoQ2hlY2soKVxyXG4gICAgcmV0dXJuIHRydWVcclxuICB9IGNhdGNoIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufSJdLCJuYW1lcyI6WyJBUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsIkFQSUVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJyZXNwb25zZSIsIm5hbWUiLCJBUElDbGllbnQiLCJyZXF1ZXN0IiwiZW5kcG9pbnQiLCJvcHRpb25zIiwidXJsIiwiYmFzZVVSTCIsImRlZmF1bHRIZWFkZXJzIiwiaGVhZGVycyIsImZldGNoIiwib2siLCJlcnJvck1lc3NhZ2UiLCJzdGF0dXNUZXh0IiwiZXJyb3JEYXRhIiwianNvbiIsImRldGFpbCIsImdldCIsImRhdGEiLCJlcnJvciIsImhlYWx0aENoZWNrIiwiZ2V0RGF0YVN1bW1hcnkiLCJnZXRTdXJmYWNlVGltZXNlcmllcyIsInBhcmFtcyIsInNlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsImxhdCIsInRvU3RyaW5nIiwibG9uIiwic3RhcnQiLCJhcHBlbmQiLCJlbmQiLCJkZXB0aCIsInVuZGVmaW5lZCIsImdldFZlcnRpY2FsUHJvZmlsZSIsImRhdGUiLCJnZXRIZWF0Q29udGVudCIsImNoYXRXaXRoRGF0YSIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiaW5nZXN0TmV0Q0RGIiwiYXBpQ2xpZW50IiwiaGFuZGxlQVBJRXJyb3IiLCJjaGVja0FQSUhlYWx0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api-client.ts\n"));

/***/ })

});