/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/chat/page",{

/***/ "(app-pages-browser)/./src/lib/api-client.ts":
/*!*******************************!*\
  !*** ./src/lib/api-client.ts ***!
  \*******************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// /**\n//  * API client for FloatChat backend services.\n//  * \n//  * Provides typed interfaces for all backend API endpoints with proper\n//  * error handling and response transformation.\n//  */\n// const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000'\n// // Type definitions for API responses\n// export interface DataSummary {\n//   total_records: number\n//   date_range: { start: string; end: string }\n//   spatial_coverage: {\n//     latitude: { min: number; max: number }\n//     longitude: { min: number; max: number }\n//   }\n//   data_types: string[]\n//   measurement_counts: Record<string, number>\n// }\n// export interface TimeSeriesPoint {\n//   time: string\n//   temperature?: number\n//   salinity?: number\n//   depth?: number\n// }\n// export interface VerticalProfilePoint {\n//   depth: number\n//   temperature?: number\n//   salinity?: number\n//   date: string\n// }\n// export interface HeatContentPoint {\n//   time: string\n//   lat: number\n//   lon: number\n//   heat_content: number\n// }\n// export interface ChatRequest {\n//   message: string\n//   context?: Record<string, any>\n// }\n// export interface ChatResponse {\n//   response: string\n//   timestamp: string\n//   sources?: string[]\n//   confidence?: number\n// }\n// // API query parameters\n// export interface TimeSeriesParams {\n//   lat: number\n//   lon: number\n//   start?: string\n//   end?: string\n//   depth?: number\n// }\n// export interface VerticalProfileParams {\n//   lat: number\n//   lon: number\n//   date: string\n// }\n// export interface HeatContentParams {\n//   lat: number\n//   lon: number\n//   start?: string\n//   end?: string\n// }\n// class APIError extends Error {\n//   constructor(\n//     message: string,\n//     public status: number,\n//     public response?: any\n//   ) {\n//     super(message)\n//     this.name = 'APIError'\n//   }\n// }\n// class APIClient {\n//   private baseURL: string\n//   constructor(baseURL: string = API_BASE_URL) {\n//     this.baseURL = baseURL\n//   }\n//   private async request<T>(\n//     endpoint: string,\n//     options: RequestInit = {}\n//   ): Promise<T> {\n//     const url = `${this.baseURL}${endpoint}`\n//     const defaultHeaders = {\n//       'Content-Type': 'application/json',\n//       ...options.headers,\n//     }\n//     try {\n//       const response = await fetch(url, {\n//         ...options,\n//         headers: defaultHeaders,\n//       })\n//       if (!response.ok) {\n//         let errorMessage = `HTTP ${response.status}: ${response.statusText}`\n//         let errorData\n//         try {\n//           errorData = await response.json()\n//           if (errorData.detail) {\n//             errorMessage = errorData.detail\n//           }\n//         } catch {\n//           // Response is not JSON, use status text\n//         }\n//         throw new APIError(errorMessage, response.status, errorData)\n//       }\n//       // Handle empty responses (like 204 No Content)\n//       if (response.status === 204 || response.headers.get('content-length') === '0') {\n//         return {} as T\n//       }\n//       const data = await response.json()\n//       return data as T\n//     } catch (error) {\n//       if (error instanceof APIError) {\n//         throw error\n//       }\n//       // Network or other errors\n//       throw new APIError(\n//         error instanceof Error ? error.message : 'Network error',\n//         0\n//       )\n//     }\n//   }\n//   // Health check\n//   async healthCheck(): Promise<{ status: string; timestamp: string; version: string }> {\n//     return this.request('/api/health')\n//   }\n//   // Data summary\n//   async getDataSummary(): Promise<DataSummary> {\n//     return this.request('/api/data-summary')\n//   }\n//   // Surface timeseries data\n//   async getSurfaceTimeseries(params: TimeSeriesParams): Promise<TimeSeriesPoint[]> {\n//     const searchParams = new URLSearchParams({\n//       lat: params.lat.toString(),\n//       lon: params.lon.toString(),\n//     })\n//     if (params.start) searchParams.append('start', params.start)\n//     if (params.end) searchParams.append('end', params.end)\n//     if (params.depth !== undefined) searchParams.append('depth', params.depth.toString())\n//     return this.request(`/api/surface-timeseries?${searchParams}`)\n//   }\n//   // Vertical profile data\n//   async getVerticalProfile(params: VerticalProfileParams): Promise<VerticalProfilePoint[]> {\n//     const searchParams = new URLSearchParams({\n//       lat: params.lat.toString(),\n//       lon: params.lon.toString(),\n//       date: params.date,\n//     })\n//     return this.request(`/api/vertical-profile?${searchParams}`)\n//   }\n//   // Heat content data\n//   async getHeatContent(params: HeatContentParams): Promise<HeatContentPoint[]> {\n//     const searchParams = new URLSearchParams({\n//       lat: params.lat.toString(),\n//       lon: params.lon.toString(),\n//     })\n//     if (params.start) searchParams.append('start', params.start)\n//     if (params.end) searchParams.append('end', params.end)\n//     return this.request(`/api/heat-content?${searchParams}`)\n//   }\n//   // Chat interface\n//   async chatWithData(request: ChatRequest): Promise<ChatResponse> {\n//     return this.request('/api/chat', {\n//       method: 'POST',\n//       body: JSON.stringify(request),\n//     })\n//   }\n//   // NetCDF ingestion (stub)\n//   async ingestNetCDF(): Promise<{ status: string; message: string }> {\n//     return this.request('/api/ingest-netcdf', {\n//       method: 'POST',\n//     })\n//   }\n// }\n// // Export singleton instance\n// export const apiClient = new APIClient()\n// // Export error class for error handling in components\n// export { APIError }\n// // Utility functions for error handling\n// export const handleAPIError = (error: unknown): string => {\n//   if (error instanceof APIError) {\n//     return error.message\n//   }\n//   if (error instanceof Error) {\n//     return error.message\n//   }\n//   return 'An unexpected error occurred'\n// }\n// // Helper function to check API availability\n// export const checkAPIHealth = async (): Promise<boolean> => {\n//   try {\n//     await apiClient.healthCheck()\n//     return true\n//   } catch {\n//     return false\n//   }\n// }\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpLWNsaWVudC50cyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNO0FBQ04sZ0RBQWdEO0FBQ2hELE1BQU07QUFDTix5RUFBeUU7QUFDekUsaURBQWlEO0FBQ2pELE1BQU07QUFFTixrRkFBa0Y7QUFFbEYsd0NBQXdDO0FBQ3hDLGlDQUFpQztBQUNqQywwQkFBMEI7QUFDMUIsK0NBQStDO0FBQy9DLHdCQUF3QjtBQUN4Qiw2Q0FBNkM7QUFDN0MsOENBQThDO0FBQzlDLE1BQU07QUFDTix5QkFBeUI7QUFDekIsK0NBQStDO0FBQy9DLElBQUk7QUFFSixxQ0FBcUM7QUFDckMsaUJBQWlCO0FBQ2pCLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CLElBQUk7QUFFSiwwQ0FBMEM7QUFDMUMsa0JBQWtCO0FBQ2xCLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEIsaUJBQWlCO0FBQ2pCLElBQUk7QUFFSixzQ0FBc0M7QUFDdEMsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIseUJBQXlCO0FBQ3pCLElBQUk7QUFFSixpQ0FBaUM7QUFDakMsb0JBQW9CO0FBQ3BCLGtDQUFrQztBQUNsQyxJQUFJO0FBRUosa0NBQWtDO0FBQ2xDLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QixJQUFJO0FBRUosMEJBQTBCO0FBQzFCLHNDQUFzQztBQUN0QyxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLElBQUk7QUFFSiwyQ0FBMkM7QUFDM0MsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsSUFBSTtBQUVKLHVDQUF1QztBQUN2QyxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsSUFBSTtBQUVKLGlDQUFpQztBQUNqQyxpQkFBaUI7QUFDakIsdUJBQXVCO0FBQ3ZCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIsUUFBUTtBQUNSLHFCQUFxQjtBQUNyQiw2QkFBNkI7QUFDN0IsTUFBTTtBQUNOLElBQUk7QUFFSixvQkFBb0I7QUFDcEIsNEJBQTRCO0FBRTVCLGtEQUFrRDtBQUNsRCw2QkFBNkI7QUFDN0IsTUFBTTtBQUVOLDhCQUE4QjtBQUM5Qix3QkFBd0I7QUFDeEIsZ0NBQWdDO0FBQ2hDLG9CQUFvQjtBQUNwQiwrQ0FBK0M7QUFFL0MsK0JBQStCO0FBQy9CLDRDQUE0QztBQUM1Qyw0QkFBNEI7QUFDNUIsUUFBUTtBQUVSLFlBQVk7QUFDWiw0Q0FBNEM7QUFDNUMsc0JBQXNCO0FBQ3RCLG1DQUFtQztBQUNuQyxXQUFXO0FBRVgsNEJBQTRCO0FBQzVCLCtFQUErRTtBQUMvRSx3QkFBd0I7QUFFeEIsZ0JBQWdCO0FBQ2hCLDhDQUE4QztBQUM5QyxvQ0FBb0M7QUFDcEMsOENBQThDO0FBQzlDLGNBQWM7QUFDZCxvQkFBb0I7QUFDcEIscURBQXFEO0FBQ3JELFlBQVk7QUFFWix1RUFBdUU7QUFDdkUsVUFBVTtBQUVWLHdEQUF3RDtBQUN4RCx5RkFBeUY7QUFDekYseUJBQXlCO0FBQ3pCLFVBQVU7QUFFViwyQ0FBMkM7QUFDM0MseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4Qix5Q0FBeUM7QUFDekMsc0JBQXNCO0FBQ3RCLFVBQVU7QUFFVixtQ0FBbUM7QUFDbkMsNEJBQTRCO0FBQzVCLG9FQUFvRTtBQUNwRSxZQUFZO0FBQ1osVUFBVTtBQUNWLFFBQVE7QUFDUixNQUFNO0FBRU4sb0JBQW9CO0FBQ3BCLDJGQUEyRjtBQUMzRix5Q0FBeUM7QUFDekMsTUFBTTtBQUVOLG9CQUFvQjtBQUNwQixtREFBbUQ7QUFDbkQsK0NBQStDO0FBQy9DLE1BQU07QUFFTiwrQkFBK0I7QUFDL0IsdUZBQXVGO0FBQ3ZGLGlEQUFpRDtBQUNqRCxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLFNBQVM7QUFFVCxtRUFBbUU7QUFDbkUsNkRBQTZEO0FBQzdELDRGQUE0RjtBQUU1RixxRUFBcUU7QUFDckUsTUFBTTtBQUVOLDZCQUE2QjtBQUM3QiwrRkFBK0Y7QUFDL0YsaURBQWlEO0FBQ2pELG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsMkJBQTJCO0FBQzNCLFNBQVM7QUFFVCxtRUFBbUU7QUFDbkUsTUFBTTtBQUVOLHlCQUF5QjtBQUN6QixtRkFBbUY7QUFDbkYsaURBQWlEO0FBQ2pELG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsU0FBUztBQUVULG1FQUFtRTtBQUNuRSw2REFBNkQ7QUFFN0QsK0RBQStEO0FBQy9ELE1BQU07QUFFTixzQkFBc0I7QUFDdEIsc0VBQXNFO0FBQ3RFLHlDQUF5QztBQUN6Qyx3QkFBd0I7QUFDeEIsdUNBQXVDO0FBQ3ZDLFNBQVM7QUFDVCxNQUFNO0FBRU4sK0JBQStCO0FBQy9CLHlFQUF5RTtBQUN6RSxrREFBa0Q7QUFDbEQsd0JBQXdCO0FBQ3hCLFNBQVM7QUFDVCxNQUFNO0FBQ04sSUFBSTtBQUVKLCtCQUErQjtBQUMvQiwyQ0FBMkM7QUFFM0MseURBQXlEO0FBQ3pELHNCQUFzQjtBQUV0QiwwQ0FBMEM7QUFDMUMsOERBQThEO0FBQzlELHFDQUFxQztBQUNyQywyQkFBMkI7QUFDM0IsTUFBTTtBQUNOLGtDQUFrQztBQUNsQywyQkFBMkI7QUFDM0IsTUFBTTtBQUNOLDBDQUEwQztBQUMxQyxJQUFJO0FBRUosK0NBQStDO0FBQy9DLGdFQUFnRTtBQUNoRSxVQUFVO0FBQ1Ysb0NBQW9DO0FBQ3BDLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2QsbUJBQW1CO0FBQ25CLE1BQU07QUFDTixJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvYXBpLWNsaWVudC50cz9hYzE0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIC8qKlxyXG4vLyAgKiBBUEkgY2xpZW50IGZvciBGbG9hdENoYXQgYmFja2VuZCBzZXJ2aWNlcy5cclxuLy8gICogXHJcbi8vICAqIFByb3ZpZGVzIHR5cGVkIGludGVyZmFjZXMgZm9yIGFsbCBiYWNrZW5kIEFQSSBlbmRwb2ludHMgd2l0aCBwcm9wZXJcclxuLy8gICogZXJyb3IgaGFuZGxpbmcgYW5kIHJlc3BvbnNlIHRyYW5zZm9ybWF0aW9uLlxyXG4vLyAgKi9cclxuXHJcbi8vIGNvbnN0IEFQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMCdcclxuXHJcbi8vIC8vIFR5cGUgZGVmaW5pdGlvbnMgZm9yIEFQSSByZXNwb25zZXNcclxuLy8gZXhwb3J0IGludGVyZmFjZSBEYXRhU3VtbWFyeSB7XHJcbi8vICAgdG90YWxfcmVjb3JkczogbnVtYmVyXHJcbi8vICAgZGF0ZV9yYW5nZTogeyBzdGFydDogc3RyaW5nOyBlbmQ6IHN0cmluZyB9XHJcbi8vICAgc3BhdGlhbF9jb3ZlcmFnZToge1xyXG4vLyAgICAgbGF0aXR1ZGU6IHsgbWluOiBudW1iZXI7IG1heDogbnVtYmVyIH1cclxuLy8gICAgIGxvbmdpdHVkZTogeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXIgfVxyXG4vLyAgIH1cclxuLy8gICBkYXRhX3R5cGVzOiBzdHJpbmdbXVxyXG4vLyAgIG1lYXN1cmVtZW50X2NvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPlxyXG4vLyB9XHJcblxyXG4vLyBleHBvcnQgaW50ZXJmYWNlIFRpbWVTZXJpZXNQb2ludCB7XHJcbi8vICAgdGltZTogc3RyaW5nXHJcbi8vICAgdGVtcGVyYXR1cmU/OiBudW1iZXJcclxuLy8gICBzYWxpbml0eT86IG51bWJlclxyXG4vLyAgIGRlcHRoPzogbnVtYmVyXHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBpbnRlcmZhY2UgVmVydGljYWxQcm9maWxlUG9pbnQge1xyXG4vLyAgIGRlcHRoOiBudW1iZXJcclxuLy8gICB0ZW1wZXJhdHVyZT86IG51bWJlclxyXG4vLyAgIHNhbGluaXR5PzogbnVtYmVyXHJcbi8vICAgZGF0ZTogc3RyaW5nXHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBpbnRlcmZhY2UgSGVhdENvbnRlbnRQb2ludCB7XHJcbi8vICAgdGltZTogc3RyaW5nXHJcbi8vICAgbGF0OiBudW1iZXJcclxuLy8gICBsb246IG51bWJlclxyXG4vLyAgIGhlYXRfY29udGVudDogbnVtYmVyXHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBpbnRlcmZhY2UgQ2hhdFJlcXVlc3Qge1xyXG4vLyAgIG1lc3NhZ2U6IHN0cmluZ1xyXG4vLyAgIGNvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBpbnRlcmZhY2UgQ2hhdFJlc3BvbnNlIHtcclxuLy8gICByZXNwb25zZTogc3RyaW5nXHJcbi8vICAgdGltZXN0YW1wOiBzdHJpbmdcclxuLy8gICBzb3VyY2VzPzogc3RyaW5nW11cclxuLy8gICBjb25maWRlbmNlPzogbnVtYmVyXHJcbi8vIH1cclxuXHJcbi8vIC8vIEFQSSBxdWVyeSBwYXJhbWV0ZXJzXHJcbi8vIGV4cG9ydCBpbnRlcmZhY2UgVGltZVNlcmllc1BhcmFtcyB7XHJcbi8vICAgbGF0OiBudW1iZXJcclxuLy8gICBsb246IG51bWJlclxyXG4vLyAgIHN0YXJ0Pzogc3RyaW5nXHJcbi8vICAgZW5kPzogc3RyaW5nXHJcbi8vICAgZGVwdGg/OiBudW1iZXJcclxuLy8gfVxyXG5cclxuLy8gZXhwb3J0IGludGVyZmFjZSBWZXJ0aWNhbFByb2ZpbGVQYXJhbXMge1xyXG4vLyAgIGxhdDogbnVtYmVyXHJcbi8vICAgbG9uOiBudW1iZXJcclxuLy8gICBkYXRlOiBzdHJpbmdcclxuLy8gfVxyXG5cclxuLy8gZXhwb3J0IGludGVyZmFjZSBIZWF0Q29udGVudFBhcmFtcyB7XHJcbi8vICAgbGF0OiBudW1iZXJcclxuLy8gICBsb246IG51bWJlclxyXG4vLyAgIHN0YXJ0Pzogc3RyaW5nXHJcbi8vICAgZW5kPzogc3RyaW5nXHJcbi8vIH1cclxuXHJcbi8vIGNsYXNzIEFQSUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4vLyAgIGNvbnN0cnVjdG9yKFxyXG4vLyAgICAgbWVzc2FnZTogc3RyaW5nLFxyXG4vLyAgICAgcHVibGljIHN0YXR1czogbnVtYmVyLFxyXG4vLyAgICAgcHVibGljIHJlc3BvbnNlPzogYW55XHJcbi8vICAgKSB7XHJcbi8vICAgICBzdXBlcihtZXNzYWdlKVxyXG4vLyAgICAgdGhpcy5uYW1lID0gJ0FQSUVycm9yJ1xyXG4vLyAgIH1cclxuLy8gfVxyXG5cclxuLy8gY2xhc3MgQVBJQ2xpZW50IHtcclxuLy8gICBwcml2YXRlIGJhc2VVUkw6IHN0cmluZ1xyXG5cclxuLy8gICBjb25zdHJ1Y3RvcihiYXNlVVJMOiBzdHJpbmcgPSBBUElfQkFTRV9VUkwpIHtcclxuLy8gICAgIHRoaXMuYmFzZVVSTCA9IGJhc2VVUkxcclxuLy8gICB9XHJcblxyXG4vLyAgIHByaXZhdGUgYXN5bmMgcmVxdWVzdDxUPihcclxuLy8gICAgIGVuZHBvaW50OiBzdHJpbmcsXHJcbi8vICAgICBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHt9XHJcbi8vICAgKTogUHJvbWlzZTxUPiB7XHJcbi8vICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVUkx9JHtlbmRwb2ludH1gXHJcbiAgICBcclxuLy8gICAgIGNvbnN0IGRlZmF1bHRIZWFkZXJzID0ge1xyXG4vLyAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4vLyAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXHJcbi8vICAgICB9XHJcblxyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcclxuLy8gICAgICAgICAuLi5vcHRpb25zLFxyXG4vLyAgICAgICAgIGhlYWRlcnM6IGRlZmF1bHRIZWFkZXJzLFxyXG4vLyAgICAgICB9KVxyXG5cclxuLy8gICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4vLyAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gXHJcbi8vICAgICAgICAgbGV0IGVycm9yRGF0YVxyXG5cclxuLy8gICAgICAgICB0cnkge1xyXG4vLyAgICAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbi8vICAgICAgICAgICBpZiAoZXJyb3JEYXRhLmRldGFpbCkge1xyXG4vLyAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvckRhdGEuZGV0YWlsXHJcbi8vICAgICAgICAgICB9XHJcbi8vICAgICAgICAgfSBjYXRjaCB7XHJcbi8vICAgICAgICAgICAvLyBSZXNwb25zZSBpcyBub3QgSlNPTiwgdXNlIHN0YXR1cyB0ZXh0XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICB0aHJvdyBuZXcgQVBJRXJyb3IoZXJyb3JNZXNzYWdlLCByZXNwb25zZS5zdGF0dXMsIGVycm9yRGF0YSlcclxuLy8gICAgICAgfVxyXG5cclxuLy8gICAgICAgLy8gSGFuZGxlIGVtcHR5IHJlc3BvbnNlcyAobGlrZSAyMDQgTm8gQ29udGVudClcclxuLy8gICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0IHx8IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LWxlbmd0aCcpID09PSAnMCcpIHtcclxuLy8gICAgICAgICByZXR1cm4ge30gYXMgVFxyXG4vLyAgICAgICB9XHJcblxyXG4vLyAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbi8vICAgICAgIHJldHVybiBkYXRhIGFzIFRcclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFQSUVycm9yKSB7XHJcbi8vICAgICAgICAgdGhyb3cgZXJyb3JcclxuLy8gICAgICAgfVxyXG5cclxuLy8gICAgICAgLy8gTmV0d29yayBvciBvdGhlciBlcnJvcnNcclxuLy8gICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKFxyXG4vLyAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ05ldHdvcmsgZXJyb3InLFxyXG4vLyAgICAgICAgIDBcclxuLy8gICAgICAgKVxyXG4vLyAgICAgfVxyXG4vLyAgIH1cclxuXHJcbi8vICAgLy8gSGVhbHRoIGNoZWNrXHJcbi8vICAgYXN5bmMgaGVhbHRoQ2hlY2soKTogUHJvbWlzZTx7IHN0YXR1czogc3RyaW5nOyB0aW1lc3RhbXA6IHN0cmluZzsgdmVyc2lvbjogc3RyaW5nIH0+IHtcclxuLy8gICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJy9hcGkvaGVhbHRoJylcclxuLy8gICB9XHJcblxyXG4vLyAgIC8vIERhdGEgc3VtbWFyeVxyXG4vLyAgIGFzeW5jIGdldERhdGFTdW1tYXJ5KCk6IFByb21pc2U8RGF0YVN1bW1hcnk+IHtcclxuLy8gICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJy9hcGkvZGF0YS1zdW1tYXJ5JylcclxuLy8gICB9XHJcblxyXG4vLyAgIC8vIFN1cmZhY2UgdGltZXNlcmllcyBkYXRhXHJcbi8vICAgYXN5bmMgZ2V0U3VyZmFjZVRpbWVzZXJpZXMocGFyYW1zOiBUaW1lU2VyaWVzUGFyYW1zKTogUHJvbWlzZTxUaW1lU2VyaWVzUG9pbnRbXT4ge1xyXG4vLyAgICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XHJcbi8vICAgICAgIGxhdDogcGFyYW1zLmxhdC50b1N0cmluZygpLFxyXG4vLyAgICAgICBsb246IHBhcmFtcy5sb24udG9TdHJpbmcoKSxcclxuLy8gICAgIH0pXHJcblxyXG4vLyAgICAgaWYgKHBhcmFtcy5zdGFydCkgc2VhcmNoUGFyYW1zLmFwcGVuZCgnc3RhcnQnLCBwYXJhbXMuc3RhcnQpXHJcbi8vICAgICBpZiAocGFyYW1zLmVuZCkgc2VhcmNoUGFyYW1zLmFwcGVuZCgnZW5kJywgcGFyYW1zLmVuZClcclxuLy8gICAgIGlmIChwYXJhbXMuZGVwdGggIT09IHVuZGVmaW5lZCkgc2VhcmNoUGFyYW1zLmFwcGVuZCgnZGVwdGgnLCBwYXJhbXMuZGVwdGgudG9TdHJpbmcoKSlcclxuXHJcbi8vICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL3N1cmZhY2UtdGltZXNlcmllcz8ke3NlYXJjaFBhcmFtc31gKVxyXG4vLyAgIH1cclxuXHJcbi8vICAgLy8gVmVydGljYWwgcHJvZmlsZSBkYXRhXHJcbi8vICAgYXN5bmMgZ2V0VmVydGljYWxQcm9maWxlKHBhcmFtczogVmVydGljYWxQcm9maWxlUGFyYW1zKTogUHJvbWlzZTxWZXJ0aWNhbFByb2ZpbGVQb2ludFtdPiB7XHJcbi8vICAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcclxuLy8gICAgICAgbGF0OiBwYXJhbXMubGF0LnRvU3RyaW5nKCksXHJcbi8vICAgICAgIGxvbjogcGFyYW1zLmxvbi50b1N0cmluZygpLFxyXG4vLyAgICAgICBkYXRlOiBwYXJhbXMuZGF0ZSxcclxuLy8gICAgIH0pXHJcblxyXG4vLyAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS92ZXJ0aWNhbC1wcm9maWxlPyR7c2VhcmNoUGFyYW1zfWApXHJcbi8vICAgfVxyXG5cclxuLy8gICAvLyBIZWF0IGNvbnRlbnQgZGF0YVxyXG4vLyAgIGFzeW5jIGdldEhlYXRDb250ZW50KHBhcmFtczogSGVhdENvbnRlbnRQYXJhbXMpOiBQcm9taXNlPEhlYXRDb250ZW50UG9pbnRbXT4ge1xyXG4vLyAgICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XHJcbi8vICAgICAgIGxhdDogcGFyYW1zLmxhdC50b1N0cmluZygpLFxyXG4vLyAgICAgICBsb246IHBhcmFtcy5sb24udG9TdHJpbmcoKSxcclxuLy8gICAgIH0pXHJcblxyXG4vLyAgICAgaWYgKHBhcmFtcy5zdGFydCkgc2VhcmNoUGFyYW1zLmFwcGVuZCgnc3RhcnQnLCBwYXJhbXMuc3RhcnQpXHJcbi8vICAgICBpZiAocGFyYW1zLmVuZCkgc2VhcmNoUGFyYW1zLmFwcGVuZCgnZW5kJywgcGFyYW1zLmVuZClcclxuXHJcbi8vICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL2hlYXQtY29udGVudD8ke3NlYXJjaFBhcmFtc31gKVxyXG4vLyAgIH1cclxuXHJcbi8vICAgLy8gQ2hhdCBpbnRlcmZhY2VcclxuLy8gICBhc3luYyBjaGF0V2l0aERhdGEocmVxdWVzdDogQ2hhdFJlcXVlc3QpOiBQcm9taXNlPENoYXRSZXNwb25zZT4ge1xyXG4vLyAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnL2FwaS9jaGF0Jywge1xyXG4vLyAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuLy8gICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksXHJcbi8vICAgICB9KVxyXG4vLyAgIH1cclxuXHJcbi8vICAgLy8gTmV0Q0RGIGluZ2VzdGlvbiAoc3R1YilcclxuLy8gICBhc3luYyBpbmdlc3ROZXRDREYoKTogUHJvbWlzZTx7IHN0YXR1czogc3RyaW5nOyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xyXG4vLyAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnL2FwaS9pbmdlc3QtbmV0Y2RmJywge1xyXG4vLyAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuLy8gICAgIH0pXHJcbi8vICAgfVxyXG4vLyB9XHJcblxyXG4vLyAvLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXHJcbi8vIGV4cG9ydCBjb25zdCBhcGlDbGllbnQgPSBuZXcgQVBJQ2xpZW50KClcclxuXHJcbi8vIC8vIEV4cG9ydCBlcnJvciBjbGFzcyBmb3IgZXJyb3IgaGFuZGxpbmcgaW4gY29tcG9uZW50c1xyXG4vLyBleHBvcnQgeyBBUElFcnJvciB9XHJcblxyXG4vLyAvLyBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZXJyb3IgaGFuZGxpbmdcclxuLy8gZXhwb3J0IGNvbnN0IGhhbmRsZUFQSUVycm9yID0gKGVycm9yOiB1bmtub3duKTogc3RyaW5nID0+IHtcclxuLy8gICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBUElFcnJvcikge1xyXG4vLyAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2VcclxuLy8gICB9XHJcbi8vICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuLy8gICAgIHJldHVybiBlcnJvci5tZXNzYWdlXHJcbi8vICAgfVxyXG4vLyAgIHJldHVybiAnQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZCdcclxuLy8gfVxyXG5cclxuLy8gLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIEFQSSBhdmFpbGFiaWxpdHlcclxuLy8gZXhwb3J0IGNvbnN0IGNoZWNrQVBJSGVhbHRoID0gYXN5bmMgKCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xyXG4vLyAgIHRyeSB7XHJcbi8vICAgICBhd2FpdCBhcGlDbGllbnQuaGVhbHRoQ2hlY2soKVxyXG4vLyAgICAgcmV0dXJuIHRydWVcclxuLy8gICB9IGNhdGNoIHtcclxuLy8gICAgIHJldHVybiBmYWxzZVxyXG4vLyAgIH1cclxuLy8gfVxyXG5cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api-client.ts\n"));

/***/ })

});