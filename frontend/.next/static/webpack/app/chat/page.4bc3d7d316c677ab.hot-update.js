"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/chat/page",{

/***/ "(app-pages-browser)/./src/lib/api-client.ts":
/*!*******************************!*\
  !*** ./src/lib/api-client.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: function() { return /* binding */ APIError; },\n/* harmony export */   apiClient: function() { return /* binding */ apiClient; },\n/* harmony export */   checkAPIHealth: function() { return /* binding */ checkAPIHealth; },\n/* harmony export */   handleAPIError: function() { return /* binding */ handleAPIError; }\n/* harmony export */ });\n/**\r\n * API client for FloatChat backend services.\r\n * \r\n * Provides typed interfaces for all backend API endpoints with proper\r\n * error handling and response transformation.\r\n */ const API_BASE_URL = \"http://localhost:8000\" || 0;\nclass APIError extends Error {\n    constructor(message, status, response){\n        super(message);\n        this.status = status;\n        this.response = response;\n        this.name = \"APIError\";\n    }\n}\nclass APIClient {\n    async request(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const url = \"\".concat(this.baseURL).concat(endpoint);\n        const defaultHeaders = {\n            \"Content-Type\": \"application/json\",\n            ...options.headers\n        };\n        try {\n            const response = await fetch(url, {\n                ...options,\n                headers: defaultHeaders\n            });\n            if (!response.ok) {\n                let errorMessage = \"HTTP \".concat(response.status, \": \").concat(response.statusText);\n                let errorData;\n                try {\n                    errorData = await response.json();\n                    if (errorData.detail) {\n                        errorMessage = errorData.detail;\n                    }\n                } catch (e) {\n                // Response is not JSON, use status text\n                }\n                throw new APIError(errorMessage, response.status, errorData);\n            }\n            // Handle empty responses (like 204 No Content)\n            if (response.status === 204 || response.headers.get(\"content-length\") === \"0\") {\n                return {};\n            }\n            const data = await response.json();\n            return data;\n        } catch (error) {\n            if (error instanceof APIError) {\n                throw error;\n            }\n            // Network or other errors\n            throw new APIError(error instanceof Error ? error.message : \"Network error\", 0);\n        }\n    }\n    // Health check\n    async healthCheck() {\n        return this.request(\"/api/health\");\n    }\n    // Data summary\n    async getDataSummary() {\n        return this.request(\"/api/data-summary\");\n    }\n    // Surface timeseries data\n    async getSurfaceTimeseries(params) {\n        const searchParams = new URLSearchParams({\n            lat: params.lat.toString(),\n            lon: params.lon.toString()\n        });\n        if (params.start) searchParams.append(\"start\", params.start);\n        if (params.end) searchParams.append(\"end\", params.end);\n        if (params.depth !== undefined) searchParams.append(\"depth\", params.depth.toString());\n        return this.request(\"/api/surface-timeseries?\".concat(searchParams));\n    }\n    // Vertical profile data\n    async getVerticalProfile(params) {\n        const searchParams = new URLSearchParams({\n            lat: params.lat.toString(),\n            lon: params.lon.toString(),\n            date: params.date\n        });\n        return this.request(\"/api/vertical-profile?\".concat(searchParams));\n    }\n    // Heat content data\n    async getHeatContent(params) {\n        const searchParams = new URLSearchParams({\n            lat: params.lat.toString(),\n            lon: params.lon.toString()\n        });\n        if (params.start) searchParams.append(\"start\", params.start);\n        if (params.end) searchParams.append(\"end\", params.end);\n        return this.request(\"/api/heat-content?\".concat(searchParams));\n    }\n    // Chat interface\n    async chatWithData(request) {\n        return this.request(\"/api/chat\", {\n            method: \"POST\",\n            body: JSON.stringify(request)\n        });\n    }\n    // NetCDF ingestion (stub)\n    async ingestNetCDF() {\n        return this.request(\"/api/ingest-netcdf\", {\n            method: \"POST\"\n        });\n    }\n    constructor(baseURL = API_BASE_URL){\n        this.baseURL = baseURL;\n    }\n}\n// Export singleton instance\nconst apiClient = new APIClient();\n// Export error class for error handling in components\n\n// Utility functions for error handling\nconst handleAPIError = (error)=>{\n    if (error instanceof APIError) {\n        return error.message;\n    }\n    if (error instanceof Error) {\n        return error.message;\n    }\n    return \"An unexpected error occurred\";\n};\n// Helper function to check API availability\nconst checkAPIHealth = async ()=>{\n    try {\n        await apiClient.healthCheck();\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpLWNsaWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FFRCxNQUFNQSxlQUFlQyx1QkFBK0IsSUFBSTtBQXNFeEQsTUFBTUcsaUJBQWlCQztJQUNyQkMsWUFDRUMsT0FBZSxFQUNmLE1BQXFCLEVBQ3JCLFFBQXFCLENBQ3JCO1FBQ0EsS0FBSyxDQUFDQTthQUhDQyxTQUFBQTthQUNBQyxXQUFBQTtRQUdQLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU1DO0lBT0osTUFBY0MsUUFDWkMsUUFBZ0IsRUFFSjtZQURaQyxVQUFBQSxpRUFBdUIsQ0FBQztRQUV4QixNQUFNQyxNQUFNLEdBQWtCRixPQUFmLElBQUksQ0FBQ0csT0FBTyxFQUFZLE9BQVRIO1FBRTlCLE1BQU1JLGlCQUFpQjtZQUNyQixnQkFBZ0I7WUFDaEIsR0FBR0gsUUFBUUksT0FBTztRQUNwQjtRQUVBLElBQUk7WUFDRixNQUFNVCxXQUFXLE1BQU1VLE1BQU1KLEtBQUs7Z0JBQ2hDLEdBQUdELE9BQU87Z0JBQ1ZJLFNBQVNEO1lBQ1g7WUFFQSxJQUFJLENBQUNSLFNBQVNXLEVBQUUsRUFBRTtnQkFDaEIsSUFBSUMsZUFBZSxRQUE0QlosT0FBcEJBLFNBQVNELE1BQU0sRUFBQyxNQUF3QixPQUFwQkMsU0FBU2EsVUFBVTtnQkFDbEUsSUFBSUM7Z0JBRUosSUFBSTtvQkFDRkEsWUFBWSxNQUFNZCxTQUFTZSxJQUFJO29CQUMvQixJQUFJRCxVQUFVRSxNQUFNLEVBQUU7d0JBQ3BCSixlQUFlRSxVQUFVRSxNQUFNO29CQUNqQztnQkFDRixFQUFFLFVBQU07Z0JBQ04sd0NBQXdDO2dCQUMxQztnQkFFQSxNQUFNLElBQUlyQixTQUFTaUIsY0FBY1osU0FBU0QsTUFBTSxFQUFFZTtZQUNwRDtZQUVBLCtDQUErQztZQUMvQyxJQUFJZCxTQUFTRCxNQUFNLEtBQUssT0FBT0MsU0FBU1MsT0FBTyxDQUFD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QUFJcUIsaUJBQWlCdkIsT0FBTztRQUMxQixPQUFPdUIsTUFBTXJCLE9BQU87SUFDdEI7SUFDQSxPQUFPO0FBQ1QsRUFBQztBQUVELDRDQUE0QztBQUNyQyxNQUFNK0MsaUJBQWlCO0lBQzVCLElBQUk7UUFDRixNQUFNRixVQUFVdkIsV0FBVztRQUMzQixPQUFPO0lBQ1QsRUFBRSxVQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0YsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2FwaS1jbGllbnQudHM/YWMxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQVBJIGNsaWVudCBmb3IgRmxvYXRDaGF0IGJhY2tlbmQgc2VydmljZXMuXHJcbiAqIFxyXG4gKiBQcm92aWRlcyB0eXBlZCBpbnRlcmZhY2VzIGZvciBhbGwgYmFja2VuZCBBUEkgZW5kcG9pbnRzIHdpdGggcHJvcGVyXHJcbiAqIGVycm9yIGhhbmRsaW5nIGFuZCByZXNwb25zZSB0cmFuc2Zvcm1hdGlvbi5cclxuICovXHJcblxyXG5jb25zdCBBUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAnXHJcblxyXG4vLyBUeXBlIGRlZmluaXRpb25zIGZvciBBUEkgcmVzcG9uc2VzXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVN1bW1hcnkge1xyXG4gIHRvdGFsX3JlY29yZHM6IG51bWJlclxyXG4gIGRhdGVfcmFuZ2U6IHsgc3RhcnQ6IHN0cmluZzsgZW5kOiBzdHJpbmcgfVxyXG4gIHNwYXRpYWxfY292ZXJhZ2U6IHtcclxuICAgIGxhdGl0dWRlOiB7IG1pbjogbnVtYmVyOyBtYXg6IG51bWJlciB9XHJcbiAgICBsb25naXR1ZGU6IHsgbWluOiBudW1iZXI7IG1heDogbnVtYmVyIH1cclxuICB9XHJcbiAgZGF0YV90eXBlczogc3RyaW5nW11cclxuICBtZWFzdXJlbWVudF9jb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUaW1lU2VyaWVzUG9pbnQge1xyXG4gIHRpbWU6IHN0cmluZ1xyXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyXHJcbiAgc2FsaW5pdHk/OiBudW1iZXJcclxuICBkZXB0aD86IG51bWJlclxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFZlcnRpY2FsUHJvZmlsZVBvaW50IHtcclxuICBkZXB0aDogbnVtYmVyXHJcbiAgdGVtcGVyYXR1cmU/OiBudW1iZXJcclxuICBzYWxpbml0eT86IG51bWJlclxyXG4gIGRhdGU6IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEhlYXRDb250ZW50UG9pbnQge1xyXG4gIHRpbWU6IHN0cmluZ1xyXG4gIGxhdDogbnVtYmVyXHJcbiAgbG9uOiBudW1iZXJcclxuICBoZWF0X2NvbnRlbnQ6IG51bWJlclxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENoYXRSZXF1ZXN0IHtcclxuICBtZXNzYWdlOiBzdHJpbmdcclxuICBjb250ZXh0PzogUmVjb3JkPHN0cmluZywgYW55PlxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENoYXRSZXNwb25zZSB7XHJcbiAgcmVzcG9uc2U6IHN0cmluZ1xyXG4gIHRpbWVzdGFtcDogc3RyaW5nXHJcbiAgc291cmNlcz86IHN0cmluZ1tdXHJcbiAgY29uZmlkZW5jZT86IG51bWJlclxyXG59XHJcblxyXG4vLyBBUEkgcXVlcnkgcGFyYW1ldGVyc1xyXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVTZXJpZXNQYXJhbXMge1xyXG4gIGxhdDogbnVtYmVyXHJcbiAgbG9uOiBudW1iZXJcclxuICBzdGFydD86IHN0cmluZ1xyXG4gIGVuZD86IHN0cmluZ1xyXG4gIGRlcHRoPzogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVmVydGljYWxQcm9maWxlUGFyYW1zIHtcclxuICBsYXQ6IG51bWJlclxyXG4gIGxvbjogbnVtYmVyXHJcbiAgZGF0ZTogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSGVhdENvbnRlbnRQYXJhbXMge1xyXG4gIGxhdDogbnVtYmVyXHJcbiAgbG9uOiBudW1iZXJcclxuICBzdGFydD86IHN0cmluZ1xyXG4gIGVuZD86IHN0cmluZ1xyXG59XHJcblxyXG5cclxuY2xhc3MgQVBJRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBtZXNzYWdlOiBzdHJpbmcsXHJcbiAgICBwdWJsaWMgc3RhdHVzOiBudW1iZXIsXHJcbiAgICBwdWJsaWMgcmVzcG9uc2U/OiBhbnlcclxuICApIHtcclxuICAgIHN1cGVyKG1lc3NhZ2UpXHJcbiAgICB0aGlzLm5hbWUgPSAnQVBJRXJyb3InXHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBBUElDbGllbnQge1xyXG4gIHByaXZhdGUgYmFzZVVSTDogc3RyaW5nXHJcblxyXG4gIGNvbnN0cnVjdG9yKGJhc2VVUkw6IHN0cmluZyA9IEFQSV9CQVNFX1VSTCkge1xyXG4gICAgdGhpcy5iYXNlVVJMID0gYmFzZVVSTFxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyByZXF1ZXN0PFQ+KFxyXG4gICAgZW5kcG9pbnQ6IHN0cmluZyxcclxuICAgIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge31cclxuICApOiBQcm9taXNlPFQ+IHtcclxuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVSTH0ke2VuZHBvaW50fWBcclxuICAgIFxyXG4gICAgY29uc3QgZGVmYXVsdEhlYWRlcnMgPSB7XHJcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xyXG4gICAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgICAgaGVhZGVyczogZGVmYXVsdEhlYWRlcnMsXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWBcclxuICAgICAgICBsZXQgZXJyb3JEYXRhXHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgICAgIGlmIChlcnJvckRhdGEuZGV0YWlsKSB7XHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yRGF0YS5kZXRhaWxcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgIC8vIFJlc3BvbnNlIGlzIG5vdCBKU09OLCB1c2Ugc3RhdHVzIHRleHRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRocm93IG5ldyBBUElFcnJvcihlcnJvck1lc3NhZ2UsIHJlc3BvbnNlLnN0YXR1cywgZXJyb3JEYXRhKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBIYW5kbGUgZW1wdHkgcmVzcG9uc2VzIChsaWtlIDIwNCBObyBDb250ZW50KVxyXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQgfHwgcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtbGVuZ3RoJykgPT09ICcwJykge1xyXG4gICAgICAgIHJldHVybiB7fSBhcyBUXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgcmV0dXJuIGRhdGEgYXMgVFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQVBJRXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBlcnJvclxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBOZXR3b3JrIG9yIG90aGVyIGVycm9yc1xyXG4gICAgICB0aHJvdyBuZXcgQVBJRXJyb3IoXHJcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnTmV0d29yayBlcnJvcicsXHJcbiAgICAgICAgMFxyXG4gICAgICApXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBIZWFsdGggY2hlY2tcclxuICBhc3luYyBoZWFsdGhDaGVjaygpOiBQcm9taXNlPHsgc3RhdHVzOiBzdHJpbmc7IHRpbWVzdGFtcDogc3RyaW5nOyB2ZXJzaW9uOiBzdHJpbmcgfT4ge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnL2FwaS9oZWFsdGgnKVxyXG4gIH1cclxuXHJcbiAgLy8gRGF0YSBzdW1tYXJ5XHJcbiAgYXN5bmMgZ2V0RGF0YVN1bW1hcnkoKTogUHJvbWlzZTxEYXRhU3VtbWFyeT4ge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnL2FwaS9kYXRhLXN1bW1hcnknKVxyXG4gIH1cclxuXHJcbiAgLy8gU3VyZmFjZSB0aW1lc2VyaWVzIGRhdGFcclxuICBhc3luYyBnZXRTdXJmYWNlVGltZXNlcmllcyhwYXJhbXM6IFRpbWVTZXJpZXNQYXJhbXMpOiBQcm9taXNlPFRpbWVTZXJpZXNQb2ludFtdPiB7XHJcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcclxuICAgICAgbGF0OiBwYXJhbXMubGF0LnRvU3RyaW5nKCksXHJcbiAgICAgIGxvbjogcGFyYW1zLmxvbi50b1N0cmluZygpLFxyXG4gICAgfSlcclxuXHJcbiAgICBpZiAocGFyYW1zLnN0YXJ0KSBzZWFyY2hQYXJhbXMuYXBwZW5kKCdzdGFydCcsIHBhcmFtcy5zdGFydClcclxuICAgIGlmIChwYXJhbXMuZW5kKSBzZWFyY2hQYXJhbXMuYXBwZW5kKCdlbmQnLCBwYXJhbXMuZW5kKVxyXG4gICAgaWYgKHBhcmFtcy5kZXB0aCAhPT0gdW5kZWZpbmVkKSBzZWFyY2hQYXJhbXMuYXBwZW5kKCdkZXB0aCcsIHBhcmFtcy5kZXB0aC50b1N0cmluZygpKVxyXG5cclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvc3VyZmFjZS10aW1lc2VyaWVzPyR7c2VhcmNoUGFyYW1zfWApXHJcbiAgfVxyXG5cclxuICAvLyBWZXJ0aWNhbCBwcm9maWxlIGRhdGFcclxuICBhc3luYyBnZXRWZXJ0aWNhbFByb2ZpbGUocGFyYW1zOiBWZXJ0aWNhbFByb2ZpbGVQYXJhbXMpOiBQcm9taXNlPFZlcnRpY2FsUHJvZmlsZVBvaW50W10+IHtcclxuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xyXG4gICAgICBsYXQ6IHBhcmFtcy5sYXQudG9TdHJpbmcoKSxcclxuICAgICAgbG9uOiBwYXJhbXMubG9uLnRvU3RyaW5nKCksXHJcbiAgICAgIGRhdGU6IHBhcmFtcy5kYXRlLFxyXG4gICAgfSlcclxuXHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL3ZlcnRpY2FsLXByb2ZpbGU/JHtzZWFyY2hQYXJhbXN9YClcclxuICB9XHJcblxyXG4gIC8vIEhlYXQgY29udGVudCBkYXRhXHJcbiAgYXN5bmMgZ2V0SGVhdENvbnRlbnQocGFyYW1zOiBIZWF0Q29udGVudFBhcmFtcyk6IFByb21pc2U8SGVhdENvbnRlbnRQb2ludFtdPiB7XHJcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcclxuICAgICAgbGF0OiBwYXJhbXMubGF0LnRvU3RyaW5nKCksXHJcbiAgICAgIGxvbjogcGFyYW1zLmxvbi50b1N0cmluZygpLFxyXG4gICAgfSlcclxuXHJcbiAgICBpZiAocGFyYW1zLnN0YXJ0KSBzZWFyY2hQYXJhbXMuYXBwZW5kKCdzdGFydCcsIHBhcmFtcy5zdGFydClcclxuICAgIGlmIChwYXJhbXMuZW5kKSBzZWFyY2hQYXJhbXMuYXBwZW5kKCdlbmQnLCBwYXJhbXMuZW5kKVxyXG5cclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvaGVhdC1jb250ZW50PyR7c2VhcmNoUGFyYW1zfWApXHJcbiAgfVxyXG5cclxuICAvLyBDaGF0IGludGVyZmFjZVxyXG4gIGFzeW5jIGNoYXRXaXRoRGF0YShyZXF1ZXN0OiBDaGF0UmVxdWVzdCk6IFByb21pc2U8Q2hhdFJlc3BvbnNlPiB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCcvYXBpL2NoYXQnLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICAvLyBOZXRDREYgaW5nZXN0aW9uIChzdHViKVxyXG4gIGFzeW5jIGluZ2VzdE5ldENERigpOiBQcm9taXNlPHsgc3RhdHVzOiBzdHJpbmc7IG1lc3NhZ2U6IHN0cmluZyB9PiB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCcvYXBpL2luZ2VzdC1uZXRjZGYnLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgfSlcclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcclxuZXhwb3J0IGNvbnN0IGFwaUNsaWVudCA9IG5ldyBBUElDbGllbnQoKVxyXG5cclxuLy8gRXhwb3J0IGVycm9yIGNsYXNzIGZvciBlcnJvciBoYW5kbGluZyBpbiBjb21wb25lbnRzXHJcbmV4cG9ydCB7IEFQSUVycm9yIH1cclxuXHJcbi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBlcnJvciBoYW5kbGluZ1xyXG5leHBvcnQgY29uc3QgaGFuZGxlQVBJRXJyb3IgPSAoZXJyb3I6IHVua25vd24pOiBzdHJpbmcgPT4ge1xyXG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEFQSUVycm9yKSB7XHJcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZVxyXG4gIH1cclxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2VcclxuICB9XHJcbiAgcmV0dXJuICdBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkJ1xyXG59XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2hlY2sgQVBJIGF2YWlsYWJpbGl0eVxyXG5leHBvcnQgY29uc3QgY2hlY2tBUElIZWFsdGggPSBhc3luYyAoKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IGFwaUNsaWVudC5oZWFsdGhDaGVjaygpXHJcbiAgICByZXR1cm4gdHJ1ZVxyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG59Il0sIm5hbWVzIjpbIkFQSV9CQVNFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiQVBJRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsInN0YXR1cyIsInJlc3BvbnNlIiwibmFtZSIsIkFQSUNsaWVudCIsInJlcXVlc3QiLCJlbmRwb2ludCIsIm9wdGlvbnMiLCJ1cmwiLCJiYXNlVVJMIiwiZGVmYXVsdEhlYWRlcnMiLCJoZWFkZXJzIiwiZmV0Y2giLCJvayIsImVycm9yTWVzc2FnZSIsInN0YXR1c1RleHQiLCJlcnJvckRhdGEiLCJqc29uIiwiZGV0YWlsIiwiZ2V0IiwiZGF0YSIsImVycm9yIiwiaGVhbHRoQ2hlY2siLCJnZXREYXRhU3VtbWFyeSIsImdldFN1cmZhY2VUaW1lc2VyaWVzIiwicGFyYW1zIiwic2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwibGF0IiwidG9TdHJpbmciLCJsb24iLCJzdGFydCIsImFwcGVuZCIsImVuZCIsImRlcHRoIiwidW5kZWZpbmVkIiwiZ2V0VmVydGljYWxQcm9maWxlIiwiZGF0ZSIsImdldEhlYXRDb250ZW50IiwiY2hhdFdpdGhEYXRhIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJpbmdlc3ROZXRDREYiLCJhcGlDbGllbnQiLCJoYW5kbGVBUElFcnJvciIsImNoZWNrQVBJSGVhbHRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api-client.ts\n"));

/***/ })

});